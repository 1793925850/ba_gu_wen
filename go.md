# 一、defer 底层原理

## 1、执行过程

每次 defer 语句在执行的时候，都会将函数进行“压栈”，函数参数会被拷贝下来。当外层函数退出时，defer 函数会按照定义的顺序逆序执行。如果 defer 执行的函数为 nil，那么会在最终调用函数中产生 panic。

## 2、为什么 defer 要按照定义的顺序逆序执行？

后⾯定义的函数可能会依赖前⾯的资源，所以要先执⾏。如果前⾯先执⾏，释放掉这个依赖，那后⾯的函数就找不到它的依赖了。

## 3、defer 函数定义时，对外部变量的引用方式？

**有两种**

**函数参数引用**以及作为**闭包引用**

**函数参数引用**：在 defer 定义时就把值传递给 defer，并被缓存起来

**闭包引用**：在 defer 真正调用的时候，根据整个上下文去确定当前的值

defer 后⾯的语句在执⾏的时候，函数调⽤的参数会被保存起来，也就是复制⼀份。在真正执⾏的时候，实际上⽤到的是复制的变量，也就是说，如果这个变量是⼀个"值类型"，那他就和定义的时候是⼀致的，如果是⼀个"引⽤"，那么就可能和定义的时候的值不⼀致。

## 4、defer 配合 recover

recover (异常捕获)可以让程序在引发 panic 的时候不会崩溃退出。



在引发 panic 的时候，panic 会停掉当前正在执⾏的程序，**但是，在这之前，它会有序的执⾏完当前 goroutine 的 defer 列表中的语句**。



通常在 defer ⾥⾯挂⼀个 recover，防⽌程序直接挂掉，类似于 try...catch，但绝对不能像 try...catch 这样使⽤，因为 panic 的作⽤不是为了抓异常。**recover 函数只在 defer 的上下⽂中才有效，如果直接调⽤ recover，会返回 nil**。

# 二、interface 常见问题

接口就是一种约定

接口分为**侵入式**和**非侵入式**，类必须明确表示自己实现了某个接口

## 1、侵入式和非侵入式的区别

### 1.1、侵入式

你的代码⾥已经**嵌⼊了别的代码**，这些代码可能是你引⼊过的框架，也可能是你通过接口继承得来的，⽐如：java 中的继承，必须显示的表明我要继承那个接口，这样你就可以拥有侵⼊代码的⼀些功能。所以我们就称这段代码是侵⼊式代码。



**优点**：

通过侵入代码与你的代码结合可以更好地利用侵入代码提供给的功能。

**缺点**：

框架外代码就不能使用了，不利于代码复用。依赖太多，重构代码太痛苦。

### 1.2、非侵入式（没有依赖，自主研发）

































