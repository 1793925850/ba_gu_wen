# 一、defer 底层原理

## 1、执行过程

每次 defer 语句在执行的时候，都会将函数进行“压栈”，函数参数会被拷贝下来。当外层函数退出时，defer 函数会按照定义的顺序逆序执行。如果 defer 执行的函数为 nil，那么会在最终调用函数中产生 panic。

## 2、为什么 defer 要按照定义的顺序逆序执行？

后⾯定义的函数可能会依赖前⾯的资源，所以要先执⾏。如果前⾯先执⾏，释放掉这个依赖，那后⾯的函数就找不到它的依赖了。

## 3、defer 函数定义时，对外部变量的引用方式？

**有两种**

**函数参数引用**以及作为**闭包引用**

**函数参数引用**：在 defer 定义时就把值传递给 defer，并被缓存起来

**闭包引用**：在 defer 真正调用的时候，根据整个上下文去确定当前的值

defer 后⾯的语句在执⾏的时候，函数调⽤的参数会被保存起来，也就是复制⼀份。在真正执⾏的时候，实际上⽤到的是复制的变量，也就是说，如果这个变量是⼀个"值类型"，那他就和定义的时候是⼀致的，如果是⼀个"引⽤"，那么就可能和定义的时候的值不⼀致。

## 4、defer 配合 recover

recover (异常捕获)可以让程序在引发 panic 的时候不会崩溃退出。



在引发 panic 的时候，panic 会停掉当前正在执⾏的程序，**但是，在这之前，它会有序的执⾏完当前 goroutine 的 defer 列表中的语句**。



通常在 defer ⾥⾯挂⼀个 recover，防⽌程序直接挂掉，类似于 try...catch，但绝对不能像 try...catch 这样使⽤，因为 panic 的作⽤不是为了抓异常。**recover 函数只在 defer 的上下⽂中才有效，如果直接调⽤ recover，会返回 nil**。

# 二、interface 常见问题

接口就是一种约定

接口分为**侵入式**和**非侵入式**，类必须明确表示自己实现了某个接口

## 1、侵入式和非侵入式的区别

### 1.1、侵入式

你的代码⾥已经**嵌⼊了别的代码**，这些代码可能是你引⼊过的框架，也可能是你通过接口继承得来的，⽐如：java 中的继承，必须显示的表明我要继承那个接口，这样你就可以拥有侵⼊代码的⼀些功能。所以我们就称这段代码是侵⼊式代码。



**优点**：

通过侵入代码与你的代码结合可以更好地利用侵入代码提供给的功能。

**缺点**：

框架外代码就不能使用了，不利于代码复用。依赖太多，重构代码太痛苦。

### 1.2、非侵入式（没有依赖，自主研发）

与侵入式相反，代码没有引入别的包或框架，完全是自主研发。

⽐如go中的接⼜，不需要显⽰的继承接口，只需要实现接口的所有⽅法就叫实现了该接口，即便该接口删掉了，也不会影响。

**优点**：

代码可复用，方便移植。非侵入式也体现了代码的设计原则：高内聚，低耦合

**缺点**：

无法复用框架提供的代码和功能

# 三、goroutine 与线程的区别

1. **使用方面**
   1. goroutine 比线程更加轻量级，可以轻松创建十万、百万，不用担心资源问题
   2. goroutine 与 channel 搭配使用，能够更加方便的实现高并发
2. **实现方面**
   1. **从资源上讲**
      1. 线程栈的内存大小⼀般固定为2MB
      2. goroutine 栈内存是可变的，初始的时候⼀般为2KB，最⼤可以扩⼤到1GB
   2. **从调度上讲**
      1. 线程的调度由 OS 的内核完成
      2. goroutine 调度由自身的调度器完成

**goroutine 与线程的联系**：

多个 goroutine 绑定在同一个线程上面，按照一定的调度算法执行

# 四、goroutine 调度机制

三个基本概念：**MPG**

1. **M**

   代表一个线程，所有的 G（goroutine）任务最终都会在 M 上执行

2. **P**

   1. 代表一个处理器，每个运行的 M 都必须绑定一个 P。P 的个数是 GOMAXPOCS，最大为256，在程序启动时固定，一般不去修改
   2. GOMAXPOCS 默认值是当前电脑的核心数，单核 CPU 就只能设置为1，如果设置 >1，在 GOMAXPOCS 函数中也会被修改为1
   3. M 和 P 的个数不一定一样多，M>=P，每一个 P 都会保存本地的 G 任务队列，另外还有一个全局的 G 任务队列。G 任务队列可以认为是线程池中的线程队列。

3. **G**

   1. 代表一个 goroutine 对象，每次 go 调用的时候都会创建一个 G 对象

# 五、goroutine 调度流程

1. **启动一个 goroutine**
   - 也就是创建一个 G 对象，然后加入到本地队列或者全局队列中
2. **查找是否有空闲的 P**
   - 如果没有，就直接返回
   - 如果有，就用系统 API 创建一个 M（线程）
3. **由这个刚创建的 M 循环执行能找到的 G 任务**
4. **G 任务执行的顺序**
   - 先从本地队列找，本地没有找到
   - 就从全局队列找，如果还没有找到
   - 就去其它 P 中找
5. **所有的 G 任务的执行是按照 go 的调用顺序执行的**
6. **如果一个系统调用或者 G 任务执行的时间太长，就会一直占用这个线程**
   1. 在启动的时候，会专门创建一个线程 sysmon，用来监控和管理，在内部挨个循环
   2. sysmon 主要执行任务（中断 G 任务）
      1. 记录所有 P 的 G 任务并⽤变量 schedtick 计数，该变量在**每执⾏**⼀个 G 任务之后递增
      2. 如果 schedtick ⼀直没有递增，说明这个 P ⼀直在执⾏同⼀个任务
      3. 如果持续超过10ms，就在这个 G 任务的栈信息加⼀个标记
      4. G 任务在执⾏的时候，会检查这个标记，然后中断⾃⼰，把⾃⼰添加到队列的末尾，执⾏下⼀个 G
   3. G 任务的恢复
      1. 中断的时候将寄存器中栈的信息保存到自己 G 对象里面
      2. 当第二次轮到⾃⼰执⾏的时候，将⾃⼰保存的栈信息复制到寄存器⾥⾯，这样就可以接着上⼀次运⾏

goroutine 是按照抢占式进⾏调度的，⼀个 goroutine 最多执⾏10ms就会换下⼀个

# 六、GC（三色标记法）

## 1、概念

1. 白色：代表最终要清理的对象内存块
2. 灰色：待处理的内存块
3. 黑色：活跃的内存块

## 2、流程

1. 起初将所有对象都置为⽩⾊
2. 扫描出所有的可达（可以搜寻到的）对象，也就是还在使⽤的，不需要清理的对象，标记为灰⾊，放⼊待处理队列
3. 从队列中提取灰⾊对象，将其引⽤对象标记为灰⾊放⼊队列，将⾃⾝标记为⿊⾊
4. 有专有的锁监视对象内存修改
5. 在完成全部的扫描和标记⼯作之后，剩余的只有⿊⾊和⽩⾊，分别代表活跃对象与回收对象
6. 清理所有的⽩⾊对象

# 七、select 实现机制

1. **锁定 scase 中所有 channel**
2. **按照随机顺序检测 scase 中的 channel 是否 ready**
   1. 如果 case 可读，读取 channel 中的数据
   2. 如果 case 可写，写入 channel
   3. 如果都没准备好，就直接返回
3. **所有 case 都没有准备好，而且没有 default**
   1. 将当前的 goroutine 加入到所有 channel 的等待队列
   1. 将当前协程转入阻塞，等待被唤醒
4. 唤醒



















