# 一、MySQL 基础

## 1、主键

用来作**唯一标识**的字段

## 2、主键、外键、索引的区别

**定义**：

主键：唯一标识一条记录，不允许重复，不允许为空

外键：外键表示另一张表的主键，允许重复，可以是空值

索引：没有重复值，但可以有一个空值

**作用**：

主键：用来保存数据的完整性

外键：主要用于和其他表建立联系

索引：为了提高查询排序的速度

## 3、表的优化

**在建表之初就要考虑拆分逻辑**



**字段优化**：

1. 尽量使⽤ TINYINT，SMALLINT，MEDIUM_INT 替代 INT 类型，如果是非负则加上 UNSIGNED
2. VARCHAR 的长度只分配真正需要的空间
3. 尽量使⽤整数或者枚举替代字符串类型
4. 时间类型尽量使⽤ TIMESTAMP 而非 DATETIME
5. 单表不要放太多字段
6. 尽量少使用 NULL，很难查询优化而且占用额外索引空间

## 4、慢查询

**基础**：

1. 设置超时时间，超过这个时间的 sql 语句被称为慢查询
2. long_query_time：默认10秒

**优化**：

1. 运行语句，找到慢查询的 sql
2. 查询区分度最高的字段
3. explain：显⽰ mysql 如何使⽤索引来处理 select 语句以及连接表，可以帮助选择更好的索引、写出更优化的查询语句
4. order by limit 形式的 sql 语句，让排序的表优先查
5. 考虑建立索引
6. 了解业务使用场景

## 5、MySQL 与 MongoDB 的区别

**数据库模型**：

MySQL：关系型

MongoDB：非关系型

**存储方式**：

MySQL：不同引擎有不同的存储方式

MongoDB：虚拟内容+持久化

**查询语句**：

MySQL：sql 语句

MongoDB：使用 MongoDB 自己的查询语句，如 use、show、find、count、sort、insert、update、save、remove、limit

**常见架构特点**：

MySQL：单点、Master-Slave、MHA、Cluster

MongoDB：通过副本集与分片来实现高可用

**数据处理方式**：

MySQL：不同引擎有不同处理特点

MongoDB：基于内存，将热数据存储在物理内存中，从而达到高速读写的目的

**海量数据的存储**：

MySQL效率相对较低，但是 MongoDB 不支持事务

## 6、MySQL 表连接

### 6.1、内/外连接

**内连接**：

驱动表中的记录在被驱动表中找不到匹配的记录，那么驱动表的这条记录**不会加⼊到最后的结果中**

**外连接**：

驱动表中的记录在被驱动表中找不到匹配的记录，也**仍需要加⼊到最后结果中**

**注意**：

对于内连接，驱动表和被驱动表的顺序可以更换；对于外连接，这个顺序不能随意更换

### 6.2、过滤条件

**where**：

不论内外连接，只要是不符合 where 子句的记录都**不会**加⼊到最后的结果中

**on**：

在内连接中与 where 等价；

在外连接中，如果驱动表中的记录在被驱动表中没有记录可以匹配，该驱动表记录仍会加⼊到结果中，对应的被驱动表字段以 null 填充

### 6.3、嵌套循环连接

如果有3个表进⾏连接，那么表1和表2完成连接后的结果作为驱动表，将表3作为被驱动表进⾏连接查询

减少被驱动表的访问次数

### 6.4、索引

在根据驱动表的⼀条记录去被驱动表中查询时，相当于确定搜索条件的单表查询，可以使⽤索引优化单表查询

在被驱动表上使用二级索引进⾏查询时，可能连接查询的变量和过滤条件都是⼆级索引的部分列，可以不用回表直接覆盖索引，所以最好不要用 * 作为查询列表，而是使⽤真正需要查询的列

# 二、MySQL 锁

## 1、Innodb 使用表锁还是行锁？

大部分情况用行锁

**使用表锁的情况**：

1. 表比较大，事务需要更新全部或者大部分数据
2. 事务涉及到多个表，比较复杂，可能引起死锁，造成大量的事务回滚

## 2、锁的种类

### 2.1、全局锁

对**整个数据库实例**加锁。

**使用场景**：全库逻辑备份，即把整个库的表都 select 出来存成文本



MySQL 提供了⼀个加全局读锁的⽅法，命令是：

```mysql
Flush tables with read lock (FTWRL)
```

当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：

1. 数据更新语句（数据的增删改）
2. 数据定义语句（包括建表、修改表结构等）
3. 更新类事务的提交语句

### 2.2、表级锁

有两种：

#### 2.2.1、表锁

**特点**：

1. 每次操作锁住整张表
2. 开销小，加锁快
3. 并发度最低

表锁的语法是：

```mysql
lock tables … read/write
```

与 FTWRL 类似，可以⽤ unlock tables 主动释放锁，也可以在客户端断开的时候⾃动释放

**注意**： lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象

#### 2.2.2、元数据锁（meta data lock，MDL）

MDL 不需要显式使⽤，在访问⼀个表的时候会被**自动加上**

**作用**：保证读写的正确性

- 当对⼀个表做增删改查操作的时候，加 MDL 读锁
- 当要对表做结构变更操作的时候，加 MDL 写锁

读锁之间不互斥，因此你可以有多个线程同时对⼀张表增删改查。读写锁之间、写锁之间是互斥的，⽤来保证变更表结构操作的安全性。因此，如果有两个线程要同时给⼀个表加字段，其中⼀个要等另⼀个执行完才能开始执行。

事务中的 MDL 锁，在语句执⾏开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。（这可能会产⽣死锁的问题）

#### 2.2.3、行锁

针对数据表中行记录的锁，也成为记录锁

**特点**：

1. 每次操作锁住一行数据
2. 开销大，加锁慢（因为要确定哪一行）
3. 发生锁冲突的概率是最低的，并发度是最高的

**两阶段锁协议**：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要到事务结束时才释放

### 2.3、加锁规则

两个“原则”、两个“优化”、一个“bug”

**两个原则**：

1. 加锁的基本单位是 next-key lock。next-key lock 是**前开后闭**区间
2. 查找过程中，访问到的对象才会加锁

**两个优化**：

1. 索引上的等值查询，给唯⼀索引加锁的时候，next-key lock 退化为**行锁**
2. 索引上的等值查询，向右遍历时且最后⼀个值不满足等值条件的时候，next-key lock 退化为**间隙锁**

**一个“bug”**：

1. 唯⼀索引上的范围查询会访问到不满足条件的第⼀个值为止。（MySQL8.0之后的版本已经修复）



以上规则是在**可重复读隔离级别** (repeatable-read) 下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。如果切换到**读提交隔离级别** (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。

### 2.4、锁的划分

#### 2.4.1、数据库角度

##### 2.4.1.1、共享锁（读锁、S 锁）

共享锁锁定的资源可以被其他⽤户读取，但不能修改

在进⾏ SELECT 的时候，会将对象进⾏共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改

**例子**：

```mysql
SELECT user_id FROM product_comment WHERE user_id = 10 LOCK IN SHARE MODE;
```

##### 2.4.1.2、排他锁（写锁、X 锁）

排它锁锁定的数据只允许**进⾏锁定操作的事务**使⽤，其他事务⽆法对已锁定的数据进⾏查询或修改

**例子**：

```mysql
SELECT user_id FROM product_comment WHERE user_id = 10 FOR UPDATE;
```

另外当对数据进⾏更新的时候，也就是 INSERT、DELETE 或者 UPDATE 的时候，数据库也会**自动**使⽤排它锁，防⽌其他事务对该数据⾏进⾏操作

##### 2.4.1.3、共享锁与排他锁

不仅可以锁住⼀⾏，也可以锁住⼀张表

**例子**：

```mysql
// 加读锁
LOCK TABLE product_comment READ;
// 解锁读锁
UNLOCK TABLE;

// 加写锁
LOCK TABLE product_comment WRITE;
// 解锁写锁
UNLOCK TABLE;
```

##### 2.4.1.4、意向锁（Intent Lock）

给更⼤⼀级别的空间⽰意⾥⾯**是否已经上过锁**

**例子**：如果我们给某⼀⾏数据加上了排它锁，数据库会⾃动给更⼤⼀级的空间，⽐如数据页或数据表加上意向锁，告诉其他⼈这个数据页或数据表已经有⼈上过排它锁了，这样当其他⼈想要获取数据表排它锁的时候，只需要了解是否有⼈已经获取了这个数据表的意向排他锁即可

如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。

#### 2.4.2、程序员角度

##### 2.4.2.1、乐观锁

认为对同⼀数据的并发操作不会总发⽣，属于⼩概率事件，不⽤每次都对数据上锁，也就是**不采⽤数据库⾃⾝的锁机制**，⽽是通过程序来实现。在程序上，我们可以采⽤版本号机制或者时间戳机制实现。

##### 2.4.2.2、悲观锁

对数据被其他事务的修改持保守态度，**会通过数据库⾃⾝的锁机制来实现**，从⽽保证数据操作的排它性。

##### 2.4.2.3、乐观锁和悲观锁的适用场景

**乐观锁**：

读多写少

优点在于程序实现，不存在死锁问题，不过适⽤场景也会相对乐观，因为它阻⽌不了除了程序以外的数据库操作

**悲观锁**：

写操作多

并发访问性不好

# 三、MySQL 事务

## 1、基本概念

1. 一个最小的不可再分的工作单元
2. 通常情况下，一个事务对应一个完整的业务

## 2、MySQL 事务特性

ACID

### 2.1、A 原子性

⼀个事务的所有操作，要么全部完成，要么都没完成，不能结束在中间环节。如果事务在执⾏过程中发⽣错误，会被回滚到事务开始之前的状态

### 2.2、C 一致性

在事务开始之前以及事务结束之后，数据库的完整性不能被破坏

### 2.3、I 隔离性

允许多个并发事务同时对数据进⾏修改和读写的能⼒，它可以防⽌由于多个事务并发执⾏时由于交叉执⾏⽽导致的数据不⼀致

### 2.4、D 持久性

事务处理结束了以后，对数据的修改是永久的，即使是发⽣了系统故障，数据也不会丢失

## 3、MySQL 四大隔离级别

**脏读**：一个事务读取另一个事务还没有提交的数据

**不可重复读**：同一个事务内，两个相同的查询返回了不同的结果

**幻读**：在一次事务中，前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行

### 3.1、RU 读不提交（Read Uncommited）

在该隔离级别下，事务之间完全不隔离，**会产⽣脏读**，⼀般情况不会使⽤

### 3.2、RC 读提交（Read Commited）

本事务读取到的是其它事务提交的最新数据，但有⼀个问题，在同⼀个事务中，前后两相同的 select 可能会读到不同的结果（幻读）

### 3.3、RR 可重复读（Repeatable Read）

在同⼀个事务中，select 的结果是事务开始时时间点的状态，因此，同⼀个事务同样的 select 操作可以读到⼀致的结果

### 3.4、serializable 串行化

读操作会隐式获取共享锁，保证不同事务之间的互斥

# 四、分布式

## 1、幂等操作

⽤户对同⼀操作发起⼀次请求或者多次请求的结果是⼀致的，不会因为多次点击⽽产⽣副作⽤

## 2、lvs 负载均衡

Linux Virtual Server：⼀个实现负载均衡的开源软件项⽬

**目标**：通过 LVS 的负载均衡技术与 Linux 操作系统实现一个高性能，高可用的 Linux 服务器集群

### 2.1、逻辑架构

1. 调度层
2. server 集群层
3. 共享存储

### 2.2、基本工作原理

**IPVS**：使用户定义的策略生效

**ipvsadn**：用于用户定义和集群服务管理的工具



**原理**：

IVS 的 IP 负载均衡技术主要通过 IPVS 实现，IPVS 虚拟⼀个 IP 地址，⽤户必须通过这个虚拟的 IP 地址访问服务器。该虚拟 IP 被称为LVS 的 VIP，访问的请求⾸先经过 LVS 的 VIP，到达负载调度器，由负载调度器从 real server 列表中选取⼀个服务节点响应⽤户的请求

## 3、lvs 和 Nginx 的区别

**负载均衡**：

LVS：4层负载均衡

Nginx：7层负载均衡

**技术原理**：

LVS：IP+TCP 端口

Nginx：URL 应用层（内容交换）

**优点**：

LVS：配置简单，效率高

Nginx：智能化，可以对客户端请求服务端响应进⾏⾃定义修改。极⼤的提升了应⽤系统在⽹络层的灵活性

**缺点**：

LVS：不理解http，ftp等应⽤协议，满⾜不了特定需求，⽐如动静分离等

Nginx：对负载均衡的设备要求很⾼，配置复杂

## 4、consul、etcd 区别

分布式微服务架构：一个应用可能由一组职责单一的服务组成

consul、etcd 都提供了相关的服务管理功能

### 4.1、区别

**服务健康检查**：

consul：服务状态、内存、硬盘等

etcd：连接心跳

**多数据中心**：

consul：支持

etcd：不支持

**使用接口**：

consul：http/dns

etcd：http/grpc

## 5、分布式事务（重点）

保证在分布式环境中，不同的数据的数据一致性

## 6、分布式锁（重点）

将多线程的锁机制应用到分布式的部署环境中

### 6.1、特点

1. 互斥性
2. 可重入：同一个节点上的同一个线程，获取到锁之后还可以再次获取这个锁
3. 锁超时：支持锁超时，防止死锁
4. 高效，高可用
5. 支持阻塞和非阻塞
6. 支持公平锁和非公平锁

### 6.2、常见分布式锁

1. MySQL
2. Redis
3. Zookeeper

## 7、淘汰算法

### 7.1、LRU（Least Recently Used）

**概念**：

最近最少使用，如果数据最近被访问过，那么将来被访问的几率也高

**实现**：

1. 设计一个链表来缓存数据
2. 新数据插入到链表头部
3. 每当缓存命中（也就是缓存数据被访问），将数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃

































