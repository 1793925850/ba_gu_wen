# 一、MySQL 基础

## 1、主键

用来作**唯一标识**的字段

## 2、主键、外键、索引的区别

**定义**：

主键：唯一标识一条记录，不允许重复，不允许为空

外键：外键表示另一张表的主键，允许重复，可以是空值

索引：没有重复值，但可以有一个空值

**作用**：

主键：用来保存数据的完整性

外键：主要用于和其他表建立联系

索引：为了提高查询排序的速度

## 3、表的优化

**在建表之初就要考虑拆分逻辑**



**字段优化**：

1. 尽量使⽤ TINYINT，SMALLINT，MEDIUM_INT 替代 INT 类型，如果是非负则加上 UNSIGNED
2. VARCHAR 的长度只分配真正需要的空间
3. 尽量使⽤整数或者枚举替代字符串类型
4. 时间类型尽量使⽤ TIMESTAMP 而非 DATETIME
5. 单表不要放太多字段
6. 尽量少使用 NULL，很难查询优化而且占用额外索引空间

## 4、慢查询

**基础**：

1. 设置超时时间，超过这个时间的 sql 语句被称为慢查询
2. long_query_time：默认10秒

**优化**：

1. 运行语句，找到慢查询的 sql
2. 查询区分度最高的字段
3. explain：显⽰ mysql 如何使⽤索引来处理 select 语句以及连接表，可以帮助选择更好的索引、写出更优化的查询语句
4. order by limit 形式的 sql 语句，让排序的表优先查
5. 考虑建立索引
6. 了解业务使用场景

## 5、MySQL 与 MongoDB 的区别

**数据库模型**：

MySQL：关系型

MongoDB：非关系型

**存储方式**：

MySQL：不同引擎有不同的存储方式

MongoDB：虚拟内容+持久化

**查询语句**：

MySQL：sql 语句

MongoDB：使用 MongoDB 自己的查询语句，如 use、show、find、count、sort、insert、update、save、remove、limit

**常见架构特点**：

MySQL：单点、Master-Slave、MHA、Cluster

MongoDB：通过副本集与分片来实现高可用

**数据处理方式**：

MySQL：不同引擎有不同处理特点

MongoDB：基于内存，将热数据存储在物理内存中，从而达到高速读写的目的

**海量数据的存储**：

MySQL效率相对较低，但是 MongoDB 不支持事务

## 6、MySQL 表连接

### 6.1、内/外连接

**内连接**：

驱动表中的记录在被驱动表中找不到匹配的记录，那么驱动表的这条记录**不会加⼊到最后的结果中**

**外连接**：

驱动表中的记录在被驱动表中找不到匹配的记录，也**仍需要加⼊到最后结果中**

**注意**：

对于内连接，驱动表和被驱动表的顺序可以更换；对于外连接，这个顺序不能随意更换

### 6.2、过滤条件

**where**：

不论内外连接，只要是不符合 where 子句的记录都**不会**加⼊到最后的结果中

**on**：

在内连接中与 where 等价；

在外连接中，如果驱动表中的记录在被驱动表中没有记录可以匹配，该驱动表记录仍会加⼊到结果中，对应的被驱动表字段以 null 填充

### 6.3、嵌套循环连接

如果有3个表进⾏连接，那么表1和表2完成连接后的结果作为驱动表，将表3作为被驱动表进⾏连接查询

减少被驱动表的访问次数

### 6.4、索引

在根据驱动表的⼀条记录去被驱动表中查询时，相当于确定搜索条件的单表查询，可以使⽤索引优化单表查询

在被驱动表上使用二级索引进⾏查询时，可能连接查询的变量和过滤条件都是⼆级索引的部分列，可以不用回表直接覆盖索引，所以最好不要用 * 作为查询列表，而是使⽤真正需要查询的列

# 二、MySQL 锁

## 1、Innodb 使用表锁还是行锁？

大部分情况用行锁

**使用表锁的情况**：

1. 表比较大，事务需要更新全部或者大部分数据
2. 事务涉及到多个表，比较复杂，可能引起死锁，造成大量的事务回滚

## 2、锁的种类

### 2.1、全局锁

对**整个数据库实例**加锁。

**使用场景**：全库逻辑备份，即把整个库的表都 select 出来存成文本



MySQL 提供了⼀个加全局读锁的⽅法，命令是：

```mysql
Flush tables with read lock (FTWRL)
```

当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：

1. 数据更新语句（数据的增删改）
2. 数据定义语句（包括建表、修改表结构等）
3. 更新类事务的提交语句

### 2.2、表级锁

有两种：

#### 2.2.1、表锁

**特点**：

1. 每次操作锁住整张表
2. 开销小，加锁快
3. 并发度最低

表锁的语法是：

```mysql
lock tables … read/write
```

与 FTWRL 类似，可以⽤ unlock tables 主动释放锁，也可以在客户端断开的时候⾃动释放

**注意**： lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象

#### 2.2.2、元数据锁（meta data lock，MDL）

MDL 不需要显式使⽤，在访问⼀个表的时候会被**自动加上**

**作用**：保证读写的正确性

- 当对⼀个表做增删改查操作的时候，加 MDL 读锁
- 当要对表做结构变更操作的时候，加 MDL 写锁

读锁之间不互斥，因此你可以有多个线程同时对⼀张表增删改查。读写锁之间、写锁之间是互斥的，⽤来保证变更表结构操作的安全性。因此，如果有两个线程要同时给⼀个表加字段，其中⼀个要等另⼀个执行完才能开始执行。

事务中的 MDL 锁，在语句执⾏开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。（这可能会产⽣死锁的问题）

#### 2.2.3、行锁

针对数据表中行记录的锁，也成为记录锁

**特点**：

1. 每次操作锁住一行数据
2. 开销大，加锁慢（因为要确定哪一行）
3. 发生锁冲突的概率是最低的，并发度是最高的

**两阶段锁协议**：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要到事务结束时才释放

### 2.3、加锁规则

两个“原则”、两个“优化”、一个“bug”

**两个原则**：

1. 加锁的基本单位是 next-key lock。next-key lock 是**前开后闭**区间
2. 查找过程中，访问到的对象才会加锁

**两个优化**：

1. 索引上的等值查询，给唯⼀索引加锁的时候，next-key lock 退化为**行锁**
2. 索引上的等值查询，向右遍历时且最后⼀个值不满足等值条件的时候，next-key lock 退化为**间隙锁**

**一个“bug”**：

1. 唯⼀索引上的范围查询会访问到不满足条件的第⼀个值为止。（MySQL8.0之后的版本已经修复）



以上规则是在**可重复读隔离级别** (repeatable-read) 下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。如果切换到**读提交隔离级别** (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。

### 2.4、锁的划分

#### 2.4.1、数据库角度

##### 2.4.1.1、共享锁（读锁、S 锁）

共享锁锁定的资源可以被其他⽤户读取，但不能修改

在进⾏ SELECT 的时候，会将对象进⾏共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改

**例子**：

```mysql
SELECT user_id FROM product_comment WHERE user_id = 10 LOCK IN SHARE MODE;
```

##### 2.4.1.2、排他锁（写锁、X 锁）

排它锁锁定的数据只允许**进⾏锁定操作的事务**使⽤，其他事务⽆法对已锁定的数据进⾏查询或修改

**例子**：

```mysql
SELECT user_id FROM product_comment WHERE user_id = 10 FOR UPDATE;
```

另外当对数据进⾏更新的时候，也就是 INSERT、DELETE 或者 UPDATE 的时候，数据库也会**自动**使⽤排它锁，防⽌其他事务对该数据⾏进⾏操作

##### 2.4.1.3、共享锁与排他锁

不仅可以锁住⼀⾏，也可以锁住⼀张表

**例子**：

```mysql
// 加读锁
LOCK TABLE product_comment READ;
// 解锁读锁
UNLOCK TABLE;

// 加写锁
LOCK TABLE product_comment WRITE;
// 解锁写锁
UNLOCK TABLE;
```

##### 2.4.1.4、意向锁（Intent Lock）

给更⼤⼀级别的空间⽰意⾥⾯**是否已经上过锁**

**例子**：如果我们给某⼀⾏数据加上了排它锁，数据库会⾃动给更⼤⼀级的空间，⽐如数据页或数据表加上意向锁，告诉其他⼈这个数据页或数据表已经有⼈上过排它锁了，这样当其他⼈想要获取数据表排它锁的时候，只需要了解是否有⼈已经获取了这个数据表的意向排他锁即可

如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。

#### 2.4.2、程序员角度

##### 2.4.2.1、乐观锁

认为对同⼀数据的并发操作不会总发⽣，属于⼩概率事件，不⽤每次都对数据上锁，也就是**不采⽤数据库⾃⾝的锁机制**，⽽是通过程序来实现。在程序上，我们可以采⽤版本号机制或者时间戳机制实现。

##### 2.4.2.2、悲观锁

对数据被其他事务的修改持保守态度，**会通过数据库⾃⾝的锁机制来实现**，从⽽保证数据操作的排它性。

##### 2.4.2.3、乐观锁和悲观锁的适用场景

**乐观锁**：

读多写少

优点在于程序实现，不存在死锁问题，不过适⽤场景也会相对乐观，因为它阻⽌不了除了程序以外的数据库操作

**悲观锁**：

写操作多

并发访问性不好

# 三、MySQL 事务

## 1、基本概念

1. 一个最小的不可再分的工作单元
2. 通常情况下，一个事务对应一个完整的业务

## 2、MySQL 事务特性

ACID

### 2.1、A 原子性

⼀个事务的所有操作，要么全部完成，要么都没完成，不能结束在中间环节。如果事务在执⾏过程中发⽣错误，会被回滚到事务开始之前的状态

### 2.2、C 一致性

在事务开始之前以及事务结束之后，数据库的完整性不能被破坏

### 2.3、I 隔离性

允许多个并发事务同时对数据进⾏修改和读写的能⼒，它可以防⽌由于多个事务并发执⾏时由于交叉执⾏⽽导致的数据不⼀致

### 2.4、D 持久性

事务处理结束了以后，对数据的修改是永久的，即使是发⽣了系统故障，数据也不会丢失

## 3、MySQL 四大隔离级别

**脏读**：一个事务读取另一个事务还没有提交的数据

**不可重复读**：同一个事务内，两个相同的查询返回了不同的结果

**幻读**：在一次事务中，前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行

### 3.1、RU 读不提交（Read Uncommited）

在该隔离级别下，事务之间完全不隔离，**会产⽣脏读**，⼀般情况不会使⽤

### 3.2、RC 读提交（Read Commited）

本事务读取到的是其它事务提交的最新数据，但有⼀个问题，在同⼀个事务中，前后两相同的 select 可能会读到不同的结果（幻读）

### 3.3、RR 可重复读（Repeatable Read）

在同⼀个事务中，select 的结果是事务开始时时间点的状态，因此，同⼀个事务同样的 select 操作可以读到⼀致的结果

### 3.4、serializable 串行化

读操作会隐式获取共享锁，保证不同事务之间的互斥

# 四、分布式

## 1、幂等操作

⽤户对同⼀操作发起⼀次请求或者多次请求的结果是⼀致的，不会因为多次点击⽽产⽣副作⽤

## 2、lvs 负载均衡

Linux Virtual Server：⼀个实现负载均衡的开源软件项⽬

**目标**：通过 LVS 的负载均衡技术与 Linux 操作系统实现一个高性能，高可用的 Linux 服务器集群

### 2.1、逻辑架构

1. 调度层
2. server 集群层
3. 共享存储

### 2.2、基本工作原理

**IPVS**：使用户定义的策略生效

**ipvsadn**：用于用户定义和集群服务管理的工具



**原理**：

IVS 的 IP 负载均衡技术主要通过 IPVS 实现，IPVS 虚拟⼀个 IP 地址，⽤户必须通过这个虚拟的 IP 地址访问服务器。该虚拟 IP 被称为LVS 的 VIP，访问的请求⾸先经过 LVS 的 VIP，到达负载调度器，由负载调度器从 real server 列表中选取⼀个服务节点响应⽤户的请求

## 3、lvs 和 Nginx 的区别

**负载均衡**：

LVS：4层负载均衡

Nginx：7层负载均衡

**技术原理**：

LVS：IP+TCP 端口

Nginx：URL 应用层（内容交换）

**优点**：

LVS：配置简单，效率高

Nginx：智能化，可以对客户端请求服务端响应进⾏⾃定义修改。极⼤的提升了应⽤系统在⽹络层的灵活性

**缺点**：

LVS：不理解http，ftp等应⽤协议，满⾜不了特定需求，⽐如动静分离等

Nginx：对负载均衡的设备要求很⾼，配置复杂

## 4、consul、etcd 区别

分布式微服务架构：一个应用可能由一组职责单一的服务组成

consul、etcd 都提供了相关的服务管理功能

### 4.1、区别

**服务健康检查**：

consul：服务状态、内存、硬盘等

etcd：连接心跳

**多数据中心**：

consul：支持

etcd：不支持

**使用接口**：

consul：http/dns

etcd：http/grpc

## 5、分布式事务（重点）

保证在分布式环境中，不同的数据的数据一致性

## 6、分布式锁（重点）

将多线程的锁机制应用到分布式的部署环境中

### 6.1、特点

1. 互斥性
2. 可重入：同一个节点上的同一个线程，获取到锁之后还可以再次获取这个锁
3. 锁超时：支持锁超时，防止死锁
4. 高效，高可用
5. 支持阻塞和非阻塞
6. 支持公平锁和非公平锁

### 6.2、常见分布式锁

1. MySQL
2. Redis
3. Zookeeper

## 7、淘汰算法

### 7.1、LRU（Least Recently Used）

**概念**：

最近最少使用，如果数据最近被访问过，那么将来被访问的几率也高

**实现**：

1. 设计一个链表来缓存数据
2. 新数据插入到链表头部
3. 每当缓存命中（也就是缓存数据被访问），将数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃

### 7.2、LFU（Latest Frequently Used）

**概念**：

最不经常使⽤，如果⼀个数据在最近⼀段时间内使⽤次数很少，那么它在将来的⼀段时间内被使⽤的可能性也很⼩

**实现**：

1. LFU 每个数据块设计一个引用计数
2. 所有数据块按照引用计数排序，具有相同引用计数的数据块按照时间排序
3. 新加入的数据插入到队列尾部
4. 在队列中某一个数据被访问，该数据引用计数加1，队列重新排序需要删除数据时，将已排序的列表最后的数据块删除

### 7.3、FIFO（First In First Out）

**概念**：

先进先出，如果⼀个数据最先进⼊缓存中，就最早淘汰掉

**实现**：

直接用队列实现

## 8、一致性 hash 算法

**作用**：

该算法通常⽤于负载均衡中要求资源被均匀的分布到所有节点上，并且对资源的请求能够快速路由到对应的节点上⾯

**特点**：

1. 平衡性：哈希产生的结果要均匀的分配在整个输出空间中
2. 单调性：当数据发⽣变动的时候，对相同的数据始终映射到相同的节点，或者新增加的缓冲节点中，避免⽆法找到原来的数据
3. 稳定性：当出现节点坏掉或者需要动态扩容时，尽量减少数据的移动

**原理**：

1. 哈希环：将整个哈希的输出空间（2^32）设置为⼀个环形区域
2. 设置哈希环
3. 将服务器进⾏哈希，可以考虑使⽤服务器的编号或者ip等作为输⼊，得到⼀个输出值，将该输出值映射到输出空间的环形区域上
4. 对⽤户数据进⾏同样的hash操作，映射在环形区域上。然后让数据按照顺时针⽅向移动，遇到的第⼀个服务器就是它分配的服务器
5. 通过将整个哈希输出空间设置为⼀个环形区别，可以有效的减⼩输出空间的变化对于哈希结果的影响

## 9、CAP 原理

### 9.1、基本概念

1. C（一致性）：对于分布在不同节点上的数据，如果⼀个节点更新数据之后，其他节点都能读到这个最新的数据
2. A（可⽤性）：非故障节点在合理的时间内返回合理的响应
3. P（分区容错性）：出现网络错误，系统还能继续⼯作

### 9.2、CAP 不能同时共存

**原因**：

对于CAP理论中，分布式系统要保障整体的服务，因此**分区容错性（P）必然存在**。那么为什么CA不能同时存在？因为分区之间的通信可能通信失败

![image-20240311173030831](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403111730929.png)



CA：分布式中一般不会选择

CP：CP的代表是Zookeeper，放弃可⽤性，追求⼀致性和容错性

AP：追求分区容错性与可⽤性

## 10、BASE 理论

**Basically Available（基本可⽤）**：分布式系统在出现故障时，允许损失部分可⽤功能

**Soft State（软状态）**：允许系统中存在**中间状态**，这个状态不影响系统可⽤性

**Eventually consistent（最终⼀致性）**：在经过⼀段时间之后，所有节点的数据都会达到⼀致

# 五、MySQL 索引

索引的出现其实就是为了提⾼数据查询的效率，就像书的⽬录⼀样



**MySQL 在查询方面主要就是两种方式**：

1. 全表扫描（一个一个挨个找）
2. 根据索引检索



**创建索引**：

```mysql
create index 索引名 on 表名(列名);
```

**删除索引**：

```mysql
drop index 索引名 on 表名;
```

## 1、在 MySQL 当中，怎么查看一个 SQL 语句是否使用了索引进行检索？

1. 在 SQL 语句前，添加 explain 关键字
2. 当 type=ALL 时，表示使用**全表查询**（未使用索引）
3. 当 type=RES 时，表示使用索引

## 2、索引失效的情况

1. 模糊匹配当中以 “%” 开头时，索引失效
2. OR 有⼀边的条件字段没有索引时，索引失效
3. 使⽤复合索引的时候，没有使⽤左侧的列查找，索引失效
4. 在 where 当中索引列参加了运算，索引失效
5. 在 where 当中索引列使⽤了函数，索引失效

## 3、注意事项

1. 在任何数据库当中**主键**上都会⾃动添加索引对象（聚簇索引）
2. 在 mysql 当中，⼀个字段上如果有 unique 约束的话，也会⾃动创建索引对象
3. 索引不是越多越好，虽然索引会提⾼ select 效率，但是也降低了 insert 以及 update 的效率
4. 数据量小的表不需要建⽴索引，会增加额外的索引开销
5. 不经常使⽤的列不要建⽴索引
6. 频繁更新的列不要建⽴索引，会影响更新的效率

## 4、MySQL 的索引有几种

1. 普通索引：最基本的索引，没有任何限制
2. 唯⼀索引：与普通索引类似，但索引列的值必须是唯⼀的，允许空值
3. 主键索引：⼀种特殊的唯⼀索引，⼀个表只能有⼀个主键，不允许有空值
4. 组合索引：在多个字段上创建的索引，只有在查询条件中使用了**创建索引的第⼀个字段**，索引才会被使用
5. 全⽂索引：主要⽤来**查找⽂本中的关键字**，类似于搜索引擎

## 5、索引优化

1. 尽量避免在 where 字句中对字段进⾏空值判断，这会导致引擎放弃使⽤索引，进⾏全表扫描
2. 字段值分布很稀少的字段，不适合建⽴索引
3. 不要⽤字符字段做主键
4. 字符字段只建⽴前缀索引
5. 不要⽤外键和UNIQUE
6. 使⽤多列索引时，注意顺序和查询条件保持⼀致，同时删除不必要的单列索引

## 6、索引常见类型

### 6.1、哈希表

**优点**：

key ⽆序，插⼊数据时⽆需维护顺序（直接在最后⼀个元素后追加，即可），效率较⾼

**缺点**：

因为不是有序的，所以哈希索引做区间查询的速度是很慢

**适用场景**：

适⽤于只有等值查询的场景，⽽不适⽤频繁区间查找

### 6.2、有序数组

**优点**：

等值查询 和 区间查询 性能都挺6 （有序数组 适合 **查询**）

**缺点**：

有序数组不适合 频繁 增/删 记录的场景 （但是，有序数组**不合适 增/删**）

**适用场景**：

有序数组只适⽤于**静态（固定长度）存储引擎**，在 等值查询 和 范围（区间）查询 场景中的性能⾮常优秀

### 6.3、二叉搜索树

BST 是为了 保留了 “有序数组” 查询（⼆分，O(logN)）性能好的优点，同时解决“有序数组” 不适合 增/删 的缺点

⼆叉树是搜索效率最⾼的，但是实际上⼤多数的数据库存储却并不使⽤⼆叉树。其原因是，索引不⽌存在内存中，还要写到磁盘上

### 6.4、N 叉树

为了让⼀个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块

即，通过使⽤ N 叉树 来降低 树的⾼度，即 减少读取磁盘的次数（IO是很慢的），提⾼查询效率

### 6.5、InnoDB 索引模型

InnoDB 使⽤了 B+ 树索引模型，**每⼀个索引**在 InnoDB ⾥⾯对应**⼀棵 B+ 树**

假设建表语句如下，则对应的 2 棵 索引树（主键 ⾃动创建⼀颗；字段 k 创建 ⼀颗索引
树），如下所示：

![image-20240311204057765](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403112040815.png)

![image-20240311204119979](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403112041023.png)

### 6.6、聚簇索引和非聚簇索引

根据叶⼦节点的内容，索引类型分为主键索引和⾮主键索引

主键索引的叶⼦节点存的是整⾏数据在 InnoDB ⾥，主键索引也被称为**聚簇索引**（clustered index）

⾮主键索引的叶⼦节点存的是主键的值在 InnoDB ⾥，非主键索引也被称为**二级索引**（secondary index）

## 7、主键查询 vs 普通索引查询

**主键查询**：

直接在 主键索引 所在的 B+ 树中查询，然后直接返回查询到的叶⼦节点（此时，叶⼦节点⾥⾯就是整⾏记录）

**普通索引查询**：

⾸先，在普通索引所在的 B+ 树中，查询到待查询记录的 主键；然后，再根据这些查到的 主键，执⾏ “主键查询” （即，回表查询）

## 8、索引维护

B+ 树为了维护索引有序性，如果待插⼊记录所在的数据页已经满了，则可能造成 “页分裂”（申请⼀个新的数据页，然后将部分数据 挪过去）

**页分裂的缺点**：

1. 影响系统性能
2. 影响数据页的利⽤率
3. 主键长度越⼩，普通索引的叶⼦节点就越⼩，普通索引占⽤的空间也就越⼩
4. 所以，应该尽量使⽤ ⾃增主键，减少空间存储消耗。（但是，事⽆绝对，只是⼤多情况使⽤ ⾃增主键，下⾯也有特例）

**适合用业务字段 直接做主键，而不是使用自增主键的场景特例**：

1. 只有一个索引
2. 该索引必须是唯一索引

## 9、覆盖索引

在**普通索引树**中，就可以直接查到待查结果，⽽不需要回表



当执⾏如下语句时，这时只需要查 ID 的值，⽽ ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表

```mysql
select ID from T where k between 3 and 5;
```

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使⽤覆盖索引是⼀个常⽤的**性能优化手段**

## 10、最左前缀原则

**场景**：

当单独为⼀个不频繁的请求创建索引时，会造成空间浪费；但是，如果直接让它⾛全表查询(⼀个⼀个找)，那效率也太低了吧？此时，应该怎么做？

答：B+ 树这种索引结构，可以利⽤索引的“最左前缀”，来定位记录。

![image-20240311205700786](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403112057837.png)

**使用“最左前缀”查询**：

当查询语句是 where name like ‘张 %’时，也能够⽤上这个索引

1. 首先，查找到第⼀个符合条件的记录是 ID3
2. 然后，向后遍历，直到不满⾜条件为止

但是，使⽤ 'like %张" 时，索引失效（即，必须使⽤ 最左前缀）

最左前缀可以是**联合索引**的最左 N 个字段，也可以是字符串索引的最左 M 个字符



**Note**：

考虑到“最左前缀原则”，可以通过调整组合索引中的字段顺序，可以少维护⼀个索引

## 11、索引下推

![image-20240311210018738](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403112100784.png)

根据前缀索引规则，这个语句在搜索索引树的时候，只能⽤ “张”，找到第⼀个满⾜条件的记录 ID3；然后在 MySQL 5.6 之前，只能从 ID3 开始⼀个个回表，到主键索引上找出数据⾏，再对⽐字段值。



**概念**：

在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满⾜条件的记录，减少回表次数

![image-20240311210518005](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403112105045.png)

![image-20240311210506293](https://raw.githubusercontent.com/1793925850/user-image/master/imgs/202403112105347.png)

## 12、索引的优缺点

**优点**：

使⽤索引可以⼤⼤加快数据的检索速度（⼤⼤减少检索的数据量），这也是创建索引的最主要的原因

通过创建唯⼀性索引，可以保证数据库表中每⼀⾏数据的唯⼀性

**缺点**：

空间消耗，⼀个索引对应的就是⼀棵 b+树，每⼀个节点都是⼀个 16KB ⼤⼩的页。占⽤的空间较⼤

创建索引和维护索引需要耗费许多时间，当对表中的数据进⾏增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执⾏效率

# 六、MySQL 用户管理

**目的**：

为了保证 MySQL 服务器的安全，每个 MySQL 的⽤户应该对他们需要的数据具有适当的访问权



（暂时不写）

# 七、MySQL 语句执行

## 1、查询语句运行

### 1.1、连接器

负责跟客户端建⽴连接、获取权限、维持和管理连接



Mysql 会定期⾃动清理"空闲"连接，由参数 wait_timeout 控制的，默认值是 8 ⼩时。由于建⽴连接⽐较复杂，所以**尽量使⽤长连接**，⽽不是 短连接（少量查询后，就断开连接）但是，当 长连接 过多时，可能导致内存占⽤太⼤，被系统强⾏杀掉（OOM），即会导致MySQL 异常重启

**解决方案**：

1. 定期断开长连接
2. 5.7版本后，可以通过执行 mysql_reset_connection 来重新初始化连接资源

### 1.2、查询缓存











